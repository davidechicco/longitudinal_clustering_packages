setwd(".")
options(stringsAsFactors = FALSE)
cat("\014")
set.seed(18)

list.of.packages <- c("pacman")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos='http://cran.us.r-project.org')

library("pacman")
pacman::p_load("lcmm", "mixAK", "traj", "kml3d", "dplyr", "reshape2")

predicted.y <- function(data, coeffs)
{

  num.coeffs = length(coeffs)

  pred = NULL

  for(i_data in 1:nrow(data))
  {
    y = coeffs[1] + sum(data[i_data,] * coeffs[-1])
    pred = c(pred , y)
  }

  return(as.numeric(pred))
}

# mcc()
mcc <- function(x, y, coeffs){
  y.hat = predicted.y(x, coeffs)
  mean.y.hat = mean(y.hat)
  res.y.hat  = y.hat - mean.y.hat

  mean.y = mean(y)
  res.y = y - mean.y

  numerator = sum(res.y * res.y.hat)

  denominator = sqrt(sum(res.y^2) * sum(res.y.hat^2))

  R = numerator / denominator

  return(R)
}

# smc()
smc <- function(data)
{
  are.na = FALSE
  coeffs = data.frame(matrix(ncol = ncol(data)))

  for(i_dep in names(data))
  {
    dummy.data.frame = data.frame(matrix(ncol = length(names(data)), nrow = 1))
    colnames(dummy.data.frame) = c(i_dep, names(data)[-which(names(data) == i_dep)])
    fm = formula(dummy.data.frame)
    fit = lm(fm, data = data)
    if(any(is.na(fit$coefficients))){
      corr.var = names(fit$coefficients[is.na(fit$coefficients)])
      stop(paste(corr.var, "is perfectly correlated with a prevois measurment. It must be removed."))
    }
    coeffs[i_dep,] = fit$coefficients
  }
  coeffs = coeffs[-1,]
  if(are.na)
  {
      print("**ATTENTION**")
      print("You have perfectly correlated data among your measurments.")
      print("We recommend that you discard one of them.")
      print("Use 'check.correlation()' to find the correlated variables")
  }

  mult.corr.coeff = NULL

  for(i_dep in rownames(coeffs))
  {
    r = mcc(data[,-which(names(data) == i_dep)], data[,which(names(data) == i_dep)], coeffs[i_dep,]  )

    mult.corr.coeff = c(mult.corr.coeff, r)
  }

  return(mult.corr.coeff)

}

# reduced.eigen()
reduced.eigen <- function(data)
{
  cor = cor(data)
  diag.1 <- diag(rep(1, ncol(data)))
  min.cor = cor - diag.1

  reduced.cor = min.cor + diag(smc(data))

  e.values = eigen(reduced.cor)

  return(e.values)
}

# check.correlation()
check.correlation <- function(output, verbose = TRUE, is.return = FALSE){
  cor.mat = cor(output)

  mes.names = names(output)

  is.corr = FALSE

  corr.var = NULL

  for(i_row in mes.names[-length(mes.names)]){

    i_pos = which( mes.names == i_row)
    res.names = mes.names[(i_pos + 1) : length(mes.names)]

    for(i_col in res.names){

      if(cor.mat[i_row, i_col] > 0.999){

        corr.var = rbind(corr.var, c(i_col, i_row))

        if(verbose){
          print(paste("Correlation of ",i_row, " and ", i_col, " : ", round(cor.mat[i_row, i_col],3), sep = ""))
          is.corr = TRUE
        }
      }
    }
  }
  if(!is.corr && verbose)
    print("No correlations found. That is good.")
  if(is.return)
    return(corr.var)
}

#' @title Performs Factor Analysis to Select a Subset of the 24 Measures
#' @description Performs a factor analysis to reduce the set of 24 measures into a smaller set of measures that captures the main features of the trajectories.
#' @param trajMeasures List generated by \code{step1mesures}. Contains
#'original data, original time and 24 measures.
#' @param discard Vector containing names or numerical
#'positions of measures to discard during factor analysis.
#' @param num.factors Numerical value specifying the number
#'of factors to choose. Defaults to \code{NULL}.
#'See details.Defaults to \code{NULL}.
#' @param verbose Logical indicating if the function should
#'print information on screen. Defaults to \code{TRUE}.
#' @param \dots Arguments to be passed to \code{principal}. See details.
#' @return trajFactors Object containing the measures chosen as factors, the eigenvalues of the correlation matrix of the 24 measures, the list generated by the
#'\code{principal} function used for the factor analysis and the data stored in the \code{trajMeasures} object.
#'
#' @details If \code{num.factor} is \code{NULL},the function will select the number of factors as the number of eigenvalues greater than 1.
#'
#'The \code{\link[psych]{principal}} function is used in order to choose the measure that will represent each factor. \code{varimax} is used to rotate the data during 
#'the execution of the\ code{principal} function. Any other parameter can be passed through \code{\dots} in order to further control the \code{principal} function.
#'
#'If any measures that happen to be extremely correlated among themselves (corr. >= 0.95), one of them
#'will have to be removed. Such measures are flagged by \code{step1measures}. These values can be removed with \code{discard} or they will be automatically removed by the function.
#'
#' @author Marie-Pierre Sylvestre, Dan Vatnik
#'
#'marie-pierre.sylvestre@umontreal.ca
#'
#' @examples
#' \dontrun{
#'# Setup data 
#'data = example.data$data
#'
#' # Run step1measures and step2factors
#'s1 = step1measures(data, ID=TRUE)
#'s2 = step2factors(s1)
#'
#' # Display factors
#'head(s2$factors)
#'
#'# The next step would be to run "step3clusters"
#'}
#'
#' 
#' @seealso 
#' \code{\link[psych]{principal}} 
#' \code{\link[traj]{step1measures}}
#' 
#' @rdname step2factors
#' 
#' @export 
step2factorsDavide <- function(trajMeasures, num.factors = NULL, discard  = NULL, verbose = TRUE, ...)
{

  # Deal with varibles to discard
  if(!is.null(discard)){
    # if(class(discard) == "character")
    if(is.character(discard)) # ICI!!!!!!!!!!!!!
      vars.to.discard = which(names(trajMeasures$measurments) %in% discard)
    else
      vars.to.discard = discard

#     if(19 %in% vars.to.discard)
#       stop("m18 will automatically be removed. Do not include it in the 'discard' variable.")
#     if(length(vars.to.discard) != length(discard))
# 
#       stop("Not all variables in 'discard' are to be removed. There is an error in the format of 'discard'.")

    data = trajMeasures$measurments[,-vars.to.discard]
  }
  else
    data = trajMeasures$measurments



  # Sizing data
  dim.of.data = dim(data)
  sample.size = dim.of.data[1]

  # Deal with IDs
    IDvector = data[1]
    data = data[-1]


  # Deal with remaining correlated variables
  corr.vars = check.correlation(data, verbose = FALSE, is.return = TRUE)
  if(!is.null(corr.vars)){
    corr.vars.pos = which(names(data) %in% corr.vars[,1])
    data = data[,-corr.vars.pos]
    print(paste(corr.vars[,1], "is removed because it is perfectly correlated with", corr.vars[,2]))
  }

  # Checking validity of num.factors
  if(num.factors > ncol(data) && !is.null(num.factors))
    stop("Requesting more factors in 'num.factors' than available variables.")

  max.num.obs = dim(data)[2]

  eigen.values = NULL;
  pricipal.factors = NULL;

  # Calculate the number of factors to use
  if(is.null(num.factors))
  {
    if(verbose)
      print("Computing reduced correlation e-values...")

    eigen.values = reduced.eigen(data)

    num.factors = length(which(eigen.values$values >= 1))
  }

  # Choose the principal varaibles that will represent the factors
  principal.factors = psych::principal(data, rotate = "varimax", nfactors = num.factors, ...)
  principal.variables = c(rep(NA , num.factors))

  for(i_factors in 1: num.factors){
    principal.variables[i_factors] = which.max(abs(principal.factors$loadings[,i_factors]))
  }

  principal.variables = sort(principal.variables)

  # Bind the vectors of the factor variables to the ID vector
  output = IDvector

  for(i_col in 1 : num.factors){
    output = cbind(output, data[principal.variables[i_col]])
  }

  # Create list to export
  trajFactors = structure(list( factors  = output, e.values = eigen.values, princ.fact = principal.factors,
                  measurments = trajMeasures$measurments, data = trajMeasures$data, time = trajMeasures$time), class = "trajFactors")

  return(trajFactors)
}


paquid_CEP_zero <- paquid[which(paquid$"CEP"==0),]
paquid_CEP_one <- paquid[which(paquid$"CEP"==1),]

s1 <- NULL
s2 <- NULL
s3 <- NULL

# cat("\n\nresultsGenerator(paquid_CEP_one):\n")
# flag <- 1
# s3_paquid_CEP_one <- resultsGenerator(paquid_CEP_one, flag)

paquid_CEP <- paquid_CEP_one

cat("\n\nresultsGenerator(paquid_CEP):\n")

    paquid_ID_MMSE <- paquid_CEP %>% select("ID", "MMSE") 

    paquid_ID_MMSE$assessment_number <- ave(paquid_CEP$"age", paquid_CEP$"ID", FUN=seq_along) 

    paquid_table_by_patient_original <- reshape(paquid_ID_MMSE, idvar = "ID", timevar = "assessment_number", direction = "wide")

    paquid_table_by_patient <- paquid_table_by_patient_original %>% na.omit()

    colnames(paquid_table_by_patient)[2:ncol(paquid_table_by_patient)] <- paste0("t",1:(ncol(paquid_table_by_patient)-1))

    PATIENT_LIMIT <- 40
    paquid_table_by_patient <- paquid_table_by_patient[c(1:PATIENT_LIMIT),]
    paquid_table_by_patient <- paquid_table_by_patient %>% na.omit()

    
    cat("dim():\n")
    cat("nrow(): ", paquid_table_by_patient %>% nrow(), "\t", sep="")
    cat("ncol(): ", paquid_table_by_patient %>% ncol(), "\n", sep="")
    
    paquid_table_by_time <- paquid_table_by_patient
    for(i in c(1:ncol(paquid_table_by_time))) if(i >= 2) { paquid_table_by_time[,i] <- i-1 }

    this_datatable <- c()
    this_datatable$"data" <- paquid_table_by_patient
    this_datatable$"time" <- paquid_table_by_time

    cat("s1:\n")
    # s1 <- step1measures(this_datatable$"data", this_datatable$"time", ID = TRUE)
    s1 <- step1measures(this_datatable$"data",  ID = TRUE, verbose = TRUE)

#     cat("we remove some measurements\n")
#     s1$measurments$m15 <- NULL
#     s1$measurments$m16 <- NULL
#     s1$measurments$m17 <- NULL 
#     s1$measurments$m19  <- NULL
#     s1$measurments$m20  <- NULL
#     s1$measurments$m21  <- NULL
#     s1$measurments$m22  <- NULL
#     s1$measurments$m23  <- NULL
#     s1$measurments$m24  <- NULL

    cat("s2:\n")
    # s2 <- step2factorsDavide(s1, discard = c( "m17", "m18", "m15", "m16", "m19", "m20", "m21", "m22", "m23", "m24"), verbose = TRUE)
    s2 <- step2factors(s1, verbose = TRUE)
    
    cat("s3:\n")
    s3 <- step3clusters(s2, nclusters = 2)

    # plot(s3)
    # plotMeanTraj(s3)
    plotMedTraj(s3)
    # plotBoxplotTraj(s3)

